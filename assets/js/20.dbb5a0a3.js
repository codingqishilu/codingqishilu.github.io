(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{223:function(e,t,r){"use strict";r.r(t);var n=r(0),o=Object(n.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"content"},[e._m(0),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),r("p",[e._v("云原生 (Cloud Native) 是伴随的容器技术发展出现的的一个词，最早出自 Pivotal 公司（即开发了 Spring 的公司）的一本技术小册子 "),r("a",{attrs:{href:"https://content.pivotal.io/ebooks/migrating-to-cloud-native-application-architectures",target:"_blank",rel:"noopener noreferrer"}},[e._v("Migrating to Cloud-Native Application Architectures"),r("OutboundLink")],1),e._v("， 其中定义了云原生应用应当具备的一些特质，如无状态、可持续交付、微服务化等。随后云原生概念被广为引用，并围绕这一概念由数家大厂牵头，成立了 "),r("a",{attrs:{href:"https://www.cncf.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CNCF 基金会"),r("OutboundLink")],1),e._v("来推进云原生相关技术的发展，主要投资并孵化云原生生态内的若干项目，包括了如 Kubernetes / etcd / CoreDNS 等耳熟能详的重要项目。而这张大大的"),r("a",{attrs:{href:"https://landscape.cncf.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("云原生版图"),r("OutboundLink")],1),e._v("仍然在不断的扩展和完善。")]),e._v(" "),r("p",[e._v("从个人理解来说，传统的应用由于年代久远，更多会考虑单机部署、进程间通信等典型的“单机问题”，虽然也能工作在容器下，但由于历史包袱等原因，架构上已经很难做出大的调整。而“云原生”的应用大都是从一开始就为容器而准备，很少考虑在单机环境下使用，有些甚至无法脱离容器环境工作；考虑的场景少，从而更轻量，迭代更快。比如 etcd 之于 zookeeper ， traefik 之于 nginx 等，相信只要在容器环境下实现一次同样的功能，就能强烈的体会到云原生应用所特有的便捷之处。")]),e._v(" "),r("p",[e._v("在 CNCF 的版图下，"),r("a",{attrs:{href:"https://landscape.cncf.io/category=continuous-integration-delivery&format=card-mode&grouping=category",target:"_blank",rel:"noopener noreferrer"}},[e._v("持续集成与持续交付(Continuous Integration & Delivery)"),r("OutboundLink")],1),e._v("板块一直缺少一个钦定的主角，虽然也不乏 Travis CI、GitLab、Jenkins 这样的知名项目，但最能给人云原生应用感觉的，应该还是 "),r("a",{attrs:{href:"https://drone.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Drone"),r("OutboundLink")],1),e._v(" 这个项目，本文将"),r("a",{attrs:{href:"https://avnpc.com/pages/drone-gitflow-kubernetes-for-cloud-native-ci",target:"_blank",rel:"noopener noreferrer"}},[e._v("围绕 Drone 结合 GitFlow 及 Kubernetes 介绍一些容器环境下持续集成、持续发布 (CI/CD) 方面的实践经验"),r("OutboundLink")],1),e._v("。")]),e._v(" "),e._m(3),e._v(" "),r("p",[e._v("之前我也介绍过"),r("a",{attrs:{href:"https://avnpc.com/pages/android-auto-deploy-workflow-on-travis-ci",target:"_blank",rel:"noopener noreferrer"}},[e._v("基于 Travis CI 的一些持续集成实践"),r("OutboundLink")],1),e._v("。后来经过一些比较和调研，最终选择了 Drone 作为主力 CI 工具。截止本文，团队已经使用 Drone 有 2 年多的时间，从 v0.6 一路用到现在即将发布的 v1.0，虽然也踩了不少坑，但总的来说 Drone 还是可以满足大部分需求，并以不错的势头在完善和发展的。")]),e._v(" "),r("p",[e._v("下面这张表总结了主流的几个 CI/CD 应用的特点")]),e._v(" "),e._m(4),e._v(" "),r("p",[e._v("Travis CI 和 CircleCI 是目前"),r("a",{attrs:{href:"https://www.datanyze.com/market-share/ci/jenkins-market-share",target:"_blank",rel:"noopener noreferrer"}},[e._v("占有率最高的两个公有云 CI"),r("OutboundLink")],1),e._v("，易用性上相差无几，只是收费方式有差异。由于不支持私有部署，如果并行的任务量一大，按进程收费其实并不划算；而且由于服务器位置的原因，如果推送镜像到国内，速度很不理想。")]),e._v(" "),r("p",[e._v("Gitlab CI 虽然好用，但和 Gitlab 是深度绑定的，我们的代码托管在 Github，整体迁移代码库的成本太大，放弃。")]),e._v(" "),r("p",[e._v("Jenkins 作为老牌劲旅，也是目前市场占有率最高的 CI，几乎可以覆盖所有 CI 的使用场景，由于使用 Java 编写，配置文件使用 Groovy 语法，非常适合 Java 为主语言的团队。Jenkins 显然是可以满足我们需要的，只是团队并非 Java 为主，又已经习惯了使用 YAML 书写 CI 配置，抱着尝鲜的心态，将 Jenkins 作为了保底的选择。")]),e._v(" "),r("p",[e._v("综上，最终选择 Drone 的结论也就不难得出了，Drone 即开源，又可以私有化部署，同时作为云原生应用，官方提供了针对 Docker、Docker Swarm、K8s 等多种容器场景下的部署方案，针对不同容器场景还有特别优化，比如在 Docker Swarm 下 Drone 是以 agent 方式运行 CI 任务的，而在 K8s 下则通过创建 K8s Job 来实现，显然充分利用了容器的优势所在，这也是 Drone 优于其他 CI 应用之处。个人还觉得 Drone 的语法是所有 CI 中最容易理解和掌握的，由于 Drone 每一个步骤都是运行一个 Docker 容器，本地模拟或调试也非常容易。")]),e._v(" "),r("p",[e._v("一句话概况 Drone，可以将其看做是可以支持私有化部署的开源版 CircleCI，并且目前仍然没有看到有其他主打这个定位的 CI 工具，因此个人认为 Drone 是 CI/CD 方面云原生应用头把交椅的有力竞争者。")]),e._v(" "),e._m(5),e._v(" "),r("p",[e._v("技术选型完成后，我想首先演示一下最终的成果，希望能直观的体现出 CI 对自动化效率起到的提升，不过这就涉及到一个问题：在容器环境下，一次发布应该包含哪些内容，其中有哪些部分是可以被 CI 自动化完成的。这个问题虽然每家公司各不相同，不过按经验来说，容器环境下一次版本发布通常包含这样一个 Checklist：")]),e._v(" "),e._m(6),e._v(" "),r("p",[e._v("看上去很繁琐对吗，如果每次发布都需要人工去处理上述的所有内容，不仅容易出错，而且也无法应对 DevOps 时代一天至少数次的发布频率，那么下面就来使用 CI 来解决所有问题吧。")]),e._v(" "),e._m(7),e._v(" "),r("p",[e._v("为了对 CI 流程有最直观的认识，我创建了一个精简版的 Github 项目 "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("AlloVince/drone-ci-demo"),r("OutboundLink")],1),e._v(" 来演示完整的流程，同时项目对应的 CI 地址是 "),r("a",{attrs:{href:"https://cloud.drone.io/AlloVince/drone-ci-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("cloud.drone.io/AlloVince/drone-ci-demo"),r("OutboundLink")],1),e._v(" ，项目自动构建的 Docker 镜像会推送到 "),r("a",{attrs:{href:"https://cloud.docker.com/repository/docker/allovince/drone-ci-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("docker registry 的 allovince/drone-ci-demo"),r("OutboundLink")],1),e._v("，。为了方便说明，假设这个项目的核心文件只有 "),r("code",[e._v("index.html")]),e._v(" 一个静态页面。")]),e._v(" "),e._m(8),e._v(" "),r("p",[e._v("目前这个项目背后的 CI 都已经配置部署好，假设我是这个项目的唯一开发人员，如何开发一个新功能并发布新版本呢？")]),e._v(" "),e._m(9),e._v(" "),r("p",[e._v("虽然在开发者看来，一次发布简单到只需 3 个指令，但背后经过了如下的若干次交互，这是一次发布实际产生交互的时序图，具体每个环节如何工作将在后文中详细说明。")]),e._v(" "),r("p",[e._v("CoderGithub/masterDroneDocker RegistryKubernetesgit push通知(webhook)运行单元测试发布新版本(git release)通知(webhook)构建Docker镜像推送Docker镜像 (docker push)镜像推送成功发布新版本CoderGithub/masterDroneDocker RegistryKubernetes")]),e._v(" "),e._m(10),e._v(" "),r("p",[e._v("一个项目一般不止一个开发人员，比如我是新加入这个项目的成员，在这个 Demo 中应该如何上线新功能呢？同样非常简单：")]),e._v(" "),e._m(11),e._v(" "),r("p",[e._v("这个流程相比单人开发来多了 2 个环节，很适用于小团队合作，不仅强制加入了 Code Review 把控代码质量，同时也避免新人的不规范行为对发布带来影响。实际项目中，可以在 Github 的设置界面对 master 分支设置写入保护，这样就从根本上杜绝了误操作的可能。当然如果团队中都是熟手，就无需如此谨慎，每个人都可以负责 PR 的合并，从而进一步提升效率。")]),e._v(" "),r("p",[e._v("CoderGithub/featureLeaderGithub/masterDroneDocker RegistryKubernetesgit pushgithub pull requestCode review代码合并通知(webhook)运行单元测试发布新版本(git release)通知(webhook)构建Docker镜像推送Docker镜像 (docker push)镜像推送成功发布新版本CoderGithub/featureLeaderGithub/masterDroneDocker RegistryKubernetes")]),e._v(" "),e._m(12),e._v(" "),r("p",[e._v("在更大的项目中，参与的角色更多，一般会有开发、测试、运维几种角色的划分；还会划分出开发环境、测试环境、预发布环境、生产环境等用于代码的验证和测试；同时还会有多个功能会在同一时间并行开发。可想而知 CI 的流程也会进一步复杂。")]),e._v(" "),r("p",[e._v("能比较好应对这种复杂性的，首选 "),r("a",{attrs:{href:"https://nvie.com/posts/a-successful-git-branching-model/",target:"_blank",rel:"noopener noreferrer"}},[e._v("GitFlow 工作流"),r("OutboundLink")],1),e._v("， 即通过并行两个长期分支的方式规范代码的提交。而如果使用了 Github，由于有非常好用的 Pull Request 功能，可以将 GitFlow 进行一定程度的简化，最终有这样的工作流：")]),e._v(" "),r("p",[e._v("branch/feature-abranch/devbranch/master")]),e._v(" "),r("p",[e._v("pull request")]),e._v(" "),r("p",[e._v("pull request")]),e._v(" "),r("p",[e._v("release")]),e._v(" "),r("p",[e._v("commit-a")]),e._v(" "),r("p",[e._v("commit-b")]),e._v(" "),r("p",[e._v("commit-c")]),e._v(" "),r("p",[e._v("commit-1")]),e._v(" "),r("p",[e._v("commit-2")]),e._v(" "),r("p",[e._v("commit-3")]),e._v(" "),r("p",[e._v("commit-4")]),e._v(" "),r("p",[e._v("commit-1'")]),e._v(" "),r("p",[e._v("commit-2'")]),e._v(" "),r("p",[e._v("commit-3'")]),e._v(" "),r("p",[e._v("commit-4'")]),e._v(" "),r("p",[e._v("v1.1.0")]),e._v(" "),e._m(13),e._v(" "),r("p",[e._v("上述是从 Git 分支角度看代码仓库发生的变化，实际在开发人员视角里，工作流程是怎样的呢。假设我是项目的一名开发人员，今天开始一期新功能的开发：")]),e._v(" "),e._m(14),e._v(" "),r("p",[e._v("由此就完成了上文中 Checklist 所需的所有工作。虽然描述起来看似冗长，但不难发现实际作为开发人员，并没有任何复杂的操作，流程化的部分全部由 CI 完成，开发人员只需要关注自己的核心任务：按照工作流规范，写好代码，写好 Commit，提交代码即可。")]),e._v(" "),r("p",[e._v("接下来将介绍这个以 CI 为核心的工作流，是如何一步步搭建的。")]),e._v(" "),e._m(15),e._v(" "),e._m(16),e._v(" "),r("p",[e._v("以 Github 为例，截止本文完成时间(2019 年 3 月 28 日)， Drone 刚刚发布了第一个正式版本 v1.0.0。官方文档已经提供了分别"),r("a",{attrs:{href:"https://docs.drone.io/installation/github/",target:"_blank",rel:"noopener noreferrer"}},[e._v("基于 Docker、K8s 的 Drone 部署说明"),r("OutboundLink")],1),e._v("，不过比较简略，因此这里给出一个相对完整的配置文件。")]),e._v(" "),r("p",[e._v("首先需要在 Github "),r("a",{attrs:{href:"https://github.com/settings/developers",target:"_blank",rel:"noopener noreferrer"}},[e._v("创建一个 Auth App"),r("OutboundLink")],1),e._v("，用于 repo 的访问授权。应用创建好之后，会得到 "),r("code",[e._v("Client ID")]),e._v(" 和 "),r("code",[e._v("Client Secret")]),e._v(" 。同时 "),r("code",[e._v("Authorization callback URL")]),e._v(" 应填写 Drone 服务对应域名下的 "),r("code",[e._v("/login")]),e._v("，如"),r("code",[e._v("https://ci.avnpc.com/login")])]),e._v(" "),r("p",[e._v("Drone 支持 SQLite、MySQL、Postgres、S3 等多种后端存储，主要用于记录 build logs 等文本信息，这些信息并不是特别重要，且我们的 CI 有可能做迁移，因此个人更推荐使用 SQLite。")]),e._v(" "),r("p",[e._v("而在 K8s 环境下，SQLite 更适合用挂载 NAS 的方式供节点使用，因此首先将存储的部分独立为文件"),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/blob/master/kubernetes/drone-pvc.yaml",target:"_blank",rel:"noopener noreferrer"}},[e._v("drone-pvc.yml"),r("OutboundLink")],1),e._v("，可以根据实际情况配置 "),r("code",[e._v("nfs.path")]),e._v(" 和 "),r("code",[e._v("nfs.server")])]),e._v(" "),e._m(17),e._v(" "),r("p",[e._v("Drone 的配置主要涉及两个镜像:")]),e._v(" "),e._m(18),e._v(" "),r("p",[e._v("这部分配置较长，可以直接参考示例 "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/blob/master/kubernetes/drone.yaml",target:"_blank",rel:"noopener noreferrer"}},[e._v("drone.yaml"),r("OutboundLink")],1)]),e._v(" "),r("p",[e._v("主要涉及到的配置项包括：")]),e._v(" "),e._m(19),e._v(" "),r("p",[e._v("最后部署即可")]),e._v(" "),e._m(20),e._v(" "),e._m(21),e._v(" "),e._m(22),e._v(" "),e._m(23),e._v(" "),e._m(24),e._v(" "),e._m(25),e._v(" "),r("p",[e._v("在上例中，Drone 首先 clone git repo 代码到本地，然后根据 "),r("code",[e._v(".drone.yml")]),e._v(" 所定义的，拉取 "),r("a",{attrs:{href:"https://hub.docker.com/_/docker",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker 的官方镜像"),r("OutboundLink")],1),e._v("，然后运行该进行并挂载 git repo 的代码到 "),r("code",[e._v("/drone/src")]),e._v(" 目录。")]),e._v(" "),r("p",[e._v("在 Drone 的界面中，也可以清楚的看到这一过程。")]),e._v(" "),e._m(26),e._v(" "),r("p",[e._v("本阶段对应")]),e._v(" "),r("ul",[r("li",[e._v("代码部分: "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/tree/hello-world",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/AlloVince/drone-ci-demo/tree/hello-world"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("Drone 构建记录: "),r("a",{attrs:{href:"https://cloud.drone.io/AlloVince/drone-ci-demo/1",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://cloud.drone.io/AlloVince/drone-ci-demo/1"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("Docker 镜像: 无")])]),e._v(" "),e._m(27),e._v(" "),r("p",[e._v("有了 Hello World 的基础，接下来我们尝试将这个工作流进行扩充。")]),e._v(" "),e._m(28),e._v(" "),e._m(29),e._v(" "),r("p",[e._v("至此我们可以将工作流改进为：")]),e._v(" "),e._m(30),e._v(" "),r("p",[e._v("对应的 Drone 配置文件如下")]),e._v(" "),e._m(31),e._v(" "),r("p",[e._v("虽然比 Hello World 复杂了一些，但是可读性仍然很好，配置文件中出现了几个新概念：")]),e._v(" "),r("p",[r("strong",[e._v("Step 运行条件")]),e._v("， 即 "),r("code",[e._v("when")]),e._v(" 部分，上例中展示了当代码分支为 master，且收到一个 push；以及当代码被标记 tag 这两种情况。Drone 还支持 repo、运行结果等很多其他条件，可以参考 "),r("a",{attrs:{href:"https://docs.drone.io/user-guide/pipeline/conditions/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Drone Conditions 文档"),r("OutboundLink")],1),e._v("。")]),e._v(" "),e._m(32),e._v(" "),r("p",[e._v("Docker 这个 Plugin 由 Drone 官方提供，用于 Docker 镜像的构建和推送，具体的用法可以查看"),r("a",{attrs:{href:"http://plugins.drone.io/drone-plugins/drone-docker/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker 插件的文档"),r("OutboundLink")],1),e._v(" 。例子中演示的是将镜像推送到私有仓库，如果不做特殊配置，镜像将被推送到 Docker 的"),r("a",{attrs:{href:"https://hub.docker.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方仓库"),r("OutboundLink")],1),e._v("。")]),e._v(" "),e._m(33),e._v(" "),r("p",[e._v("目前 "),r("a",{attrs:{href:"http://plugins.drone.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Drone 的插件已经有很多"),r("OutboundLink")],1),e._v("，可以覆盖主流的云服务商和常见的工作流，并且自己制作插件的成本也不高。")]),e._v(" "),e._m(34),e._v(" "),r("ul",[r("li",[e._v("通过 Drone UI 界面中， repo -> Settings -> Secrets 添加，所添加的加密数据将保存在 Drone 的数据库中，仅能在当前 repo 中使用。")]),e._v(" "),r("li",[e._v("通过"),r("a",{attrs:{href:"https://docs.drone.io/user-guide/secrets/encrypted/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Drone cli 加密"),r("OutboundLink")],1),e._v("后保存在 "),r("code",[e._v(".drone.yml")]),e._v("文件中， 使用范围仅限 yaml 文件内")]),e._v(" "),r("li",[e._v("通过 K8s 保存为"),r("a",{attrs:{href:"https://kubernetes.io/zh/docs/concepts/configuration/secret/",target:"_blank",rel:"noopener noreferrer"}},[e._v("K8s Secret"),r("OutboundLink")],1),e._v("，称为 External Secrets，所有的 repo 都可以共享。如果是团队使用的话，这种保存方式显然是最方便的，但也要注意安全问题，因此 External Secrets 还"),r("a",{attrs:{href:"https://docs.drone.io/extend/secrets/kubernetes/config-in-kubernetes/",target:"_blank",rel:"noopener noreferrer"}},[e._v("支持 repo 级别的权限管理"),r("OutboundLink")],1),e._v("， 可以只让有当前 repo 写入权限的人才能使用对应 secret。")])]),e._v(" "),r("p",[e._v("这个阶段对应")]),e._v(" "),r("ul",[r("li",[e._v("代码仓库: "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/tree/single-person",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/AlloVince/drone-ci-demo/tree/single-person"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("push 时触发的 Drone CI: "),r("a",{attrs:{href:"https://cloud.drone.io/AlloVince/drone-ci-demo/4",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://cloud.drone.io/AlloVince/drone-ci-demo/4"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("release 时触发的 Drone CI: "),r("a",{attrs:{href:"https://cloud.drone.io/AlloVince/drone-ci-demo/5",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://cloud.drone.io/AlloVince/drone-ci-demo/5"),r("OutboundLink")],1)]),e._v(" "),e._m(35)]),e._v(" "),e._m(36),e._v(" "),r("p",[e._v("上面的工作流已经基本可以应付单人的开发了，而在团队开发时，这个工作流还需要一些扩展。不需要引入 Drone 的新功能，只需要在上文基础上根据分支做一点调整即可。")]),e._v(" "),r("p",[e._v("首先保证单元测试位于 steps 的第一位，并且限定团队工作的分支，在 push 和 pull_request 时，都能触发单元测试。")]),e._v(" "),e._m(37),e._v(" "),e._m(38),e._v(" "),e._m(39),e._v(" "),r("p",[e._v("镜像的 Tag 处不再使用自动方式，其中"),r("code",[e._v("DRONE_BRANCH")]),e._v("是 Drone 的"),r("a",{attrs:{href:"https://docs.drone.io/reference/environ/",target:"_blank",rel:"noopener noreferrer"}},[e._v("内置环境变量 (Environment)"),r("OutboundLink")],1),e._v("，对应当前的分支名。"),r("code",[e._v("##feature/")]),e._v("是执行了一个字符串的"),r("a",{attrs:{href:"https://0-8-0.docs.drone.io/substitution/",target:"_blank",rel:"noopener noreferrer"}},[e._v("替换操作 (Substitution)"),r("OutboundLink")],1),e._v("。更多的环境变量和字符串操作都可以在文档中找到。")]),e._v(" "),r("p",[e._v("以此类推，可以查看这个阶段的"),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/blob/gitflow/.drone.yml",target:"_blank",rel:"noopener noreferrer"}},[e._v("完整 "),r("code",[e._v(".drone.yml")]),r("OutboundLink")],1),e._v(" ，此时我们的工作流示例如下：")]),e._v(" "),r("ul",[r("li",[e._v("团队成员从 dev 分支 checkout 自己的分支 "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/tree/feature/readme",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("feature/readme")]),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("向"),r("code",[e._v("feature/readme")]),e._v("提交代码并 push， "),r("a",{attrs:{href:"https://cloud.drone.io/AlloVince/drone-ci-demo/8",target:"_blank",rel:"noopener noreferrer"}},[e._v("CI 运行单元测试，构建镜像"),r("OutboundLink")],1),r("code",[e._v("allovince/drone-ci-demo:readme")])]),e._v(" "),r("li",[e._v("功能开发完成后，团队成员向 dev 分支 "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/pull/1",target:"_blank",rel:"noopener noreferrer"}},[e._v("发起 pull request"),r("OutboundLink")],1),e._v(" ， "),r("a",{attrs:{href:"https://cloud.drone.io/AlloVince/drone-ci-demo/10",target:"_blank",rel:"noopener noreferrer"}},[e._v("CI 运行单元测试"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("团队其他成员 merge pull request， "),r("a",{attrs:{href:"https://cloud.drone.io/AlloVince/drone-ci-demo/11",target:"_blank",rel:"noopener noreferrer"}},[e._v("CI 运行单元测试，构建镜像"),r("OutboundLink")],1),r("code",[e._v("allovince/drone-ci-demo:test")])]),e._v(" "),r("li",[e._v("运维人员从 dev 向 master "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/pull/2",target:"_blank",rel:"noopener noreferrer"}},[e._v("发起 pull request"),r("OutboundLink")],1),e._v("，"),r("a",{attrs:{href:"https://cloud.drone.io/AlloVince/drone-ci-demo/12",target:"_blank",rel:"noopener noreferrer"}},[e._v("CI 运行单元测试，并构建镜像"),r("OutboundLink")],1),r("code",[e._v("allovince/drone-ci-demo:latest")])]),e._v(" "),r("li",[e._v("运维人员 merge pull request， 并 "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/releases/tag/pre-0.0.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("release 新版本 "),r("code",[e._v("pre-0.0.2")]),r("OutboundLink")],1),e._v("， "),r("a",{attrs:{href:"https://cloud.drone.io/AlloVince/drone-ci-demo/14",target:"_blank",rel:"noopener noreferrer"}},[e._v("CI 构建镜像"),r("OutboundLink")],1),r("code",[e._v("allovince/drone-ci-demo:pre-0.0.2")])])]),e._v(" "),e._m(40),e._v(" "),e._m(41),e._v(" "),r("p",[e._v("上面基本完成了一个支持团队协作的半自动 CI 工作流，如果不是特别苛刻的话，完全可以用上面的工作流开始干活了。")]),e._v(" "),r("p",[e._v("不过基于这个工作流工作一段时间，会发现仍然存在痛点，那就是每次发布都要想一个版本号，写 ChangeLog，并且人工去 release。")]),e._v(" "),r("p",[e._v("标记版本号涉及到上线后的回滚，追溯等一系列问题,应该是一项严肃的工作，其实如何标记早已有比较好的方案，即"),r("a",{attrs:{href:"https://semver.org/lang/zh-CN/",target:"_blank",rel:"noopener noreferrer"}},[e._v("语义化版本"),r("OutboundLink")],1),e._v("。在这个方案中，版本号一共有 3 位，形如 "),r("code",[e._v("1.0.0")]),e._v("，分别代表：")]),e._v(" "),e._m(42),e._v(" "),r("p",[e._v("虽然有了这个指导意见，但并没有很方便的解决实际问题，每次发布要搞清楚代码的修改到底是不是向下兼容的，有哪些新的功能等，仍然要花费很多时间。")]),e._v(" "),r("p",[e._v("而"),r("a",{attrs:{href:"https://semantic-release.gitbook.io/semantic-release/",target:"_blank",rel:"noopener noreferrer"}},[e._v("语义化发布 (Semantic Release)"),r("OutboundLink")],1),e._v(" 就能很好的解决这些问题。")]),e._v(" "),r("p",[e._v("语义化发布的原理很简单，就是让每一次 Commit 所附带的 Message 格式遵守一定规范，保证每次提交格式一致且都是可以被解析的，那么进行 Release 时，只要统计一下距离上次 Release 所有的提交，就分析出本次提交做了何种程度的改动，并可以自动生成版本号、自动生成 ChangeLog 等。")]),e._v(" "),r("p",[e._v("语义化发布中，Commit 所遵守的规范称为"),r("a",{attrs:{href:"https://www.conventionalcommits.org/zh/v1.0.0-beta.3/",target:"_blank",rel:"noopener noreferrer"}},[e._v("约定式提交 (Conventional Commits)"),r("OutboundLink")],1),e._v("。比如 node.js、 Angular、Electron 等知名项目都在使用这套规范。")]),e._v(" "),r("p",[e._v("语义化发布首先将 Commit 进行分类，常用的分类 (Type) 有：")]),e._v(" "),e._m(43),e._v(" "),r("p",[e._v("每个 Commit 可以对应一个作用域(Scope)，在一个项目中作用域一般可以指不同的模块。")]),e._v(" "),e._m(44),e._v(" "),r("p",[e._v("以下都是符合规范的 Commit:")]),e._v(" "),e._m(45),e._v(" "),r("p",[e._v("有了这些规范的 Commit，版本号如何变化就很容易确定了，目前语义化发布"),r("a",{attrs:{href:"https://github.com/semantic-release/commit-analyzer/blob/master/lib/default-release-rules.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("默认的规则"),r("OutboundLink")],1),e._v("如下")]),e._v(" "),e._m(46),e._v(" "),r("p",[e._v("因此在 CI 部署 semantic-release 之后，作为开发人员只需要按照规范书写 Commit 即可，其他的都由 CI 完成。")]),e._v(" "),r("p",[e._v("具体如何将语义化发布加入 CI 流程中呢， semantic-release 是 js 实现的，如果是 js 的项目，可以直接在"),r("code",[e._v("package.json")]),e._v("中增加配置项，而对于任意语言的项目，推荐像 Demo 中一样，在根目录下增加 "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/blob/semantic-release/release.config.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("配置文件"),r("code",[e._v("release.config.js")]),r("OutboundLink")],1),e._v("。这个配置目的是为了禁用默认开启的 npm 发布机制，可以直接套用。")]),e._v(" "),r("p",[e._v("semantic-release 要执行 Github release，因此我们需要在 CI 中配置自己的 "),r("a",{attrs:{href:"https://github.com/settings/tokens",target:"_blank",rel:"noopener noreferrer"}},[e._v("Personal access tokens"),r("OutboundLink")],1),e._v(" 让 CI 有 Github repo 的读写权限， 可以通过 Github 点击自己头像 -> Settings -> Developer settings -> Personal access tokens -> Generate new token 生成一个 Token。 然后在 Drone 的 repo 设置界面新增一个 Secret， key 为 "),r("code",[e._v("GITHUB_TOKEN")]),e._v("， value 填入刚生成的 Token。")]),e._v(" "),e._m(47),e._v(" "),e._m(48),e._v(" "),r("p",[e._v("来再次模拟一下流程，feature 分支部分与上文相同")]),e._v(" "),r("ul",[r("li",[e._v("从 dev 向 master "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/pull/3",target:"_blank",rel:"noopener noreferrer"}},[e._v("发起 pull request"),r("OutboundLink")],1),e._v("，"),r("a",{attrs:{href:"https://cloud.drone.io/AlloVince/drone-ci-demo/17",target:"_blank",rel:"noopener noreferrer"}},[e._v("CI 运行单元测试，并构建镜像"),r("OutboundLink")],1),r("code",[e._v("allovince/drone-ci-demo:latest")])]),e._v(" "),r("li",[e._v("merge pull request，CI 会"),r("a",{attrs:{href:"https://cloud.drone.io/AlloVince/drone-ci-demo/19",target:"_blank",rel:"noopener noreferrer"}},[e._v("执行单元测试并运行 semantic-release"),r("OutboundLink")],1),e._v(" ， 运行成功的话能看到 Github "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/releases/tag/v1.0.0",target:"_blank",rel:"noopener noreferrer"}},[e._v("新增 release v1.0.0"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("Github release 再次触发"),r("a",{attrs:{href:"https://cloud.drone.io/AlloVince/drone-ci-demo/20",target:"_blank",rel:"noopener noreferrer"}},[e._v("CI 构建生产环境用 Docker 镜像"),r("OutboundLink")],1),r("code",[e._v("allovince/drone-ci-demo:1.0.0")])])]),e._v(" "),r("p",[e._v("最终我们能得到这样一个赏心悦目的 release")]),e._v(" "),e._m(49),e._v(" "),e._m(50),e._v(" "),e._m(51),e._v(" "),r("p",[e._v("假设我们在生产环境下 drone-ci-demo 项目的 K8s 发布文件如下")]),e._v(" "),e._m(52),e._v(" "),r("p",[e._v("对应 "),r("code",[e._v(".drone.yml")]),e._v(" 中增加 step 如下。这里使用的插件是"),r("a",{attrs:{href:"https://github.com/honestbee/drone-kubernetes",target:"_blank",rel:"noopener noreferrer"}},[e._v("honestbee/drone-kubernetes"),r("OutboundLink")],1),e._v("， 插件中"),r("code",[e._v("kubectl")]),e._v(" 连接 API 使用的是证书+ Token 的方式鉴权，因此需要先获得证书及 Token， 已经授权的 Token 保存于 k8s secret，可以通过"),r("code",[e._v("kubectl get secret [ your default secret name ] -o yaml | egrep 'ca.crt:|token:'")]),e._v("获得并配置到 drone 中，注意插件要求 token 是明文的，需要 base64 解码一下："),r("code",[e._v("echo [ your token ] | base64 -d && echo ''")])]),e._v(" "),e._m(53),e._v(" "),r("p",[e._v("在"),r("a",{attrs:{href:"https://avnpc.com/pages/%5Bhttps://github.com/AlloVince/drone-ci-demo/tree/k8s-deploy%5D(https://github.com/AlloVince/drone-ci-demo/tree/k8s-deploy)",target:"_blank",rel:"noopener noreferrer"}},[e._v("示例"),r("OutboundLink")],1),e._v("中，可以看到在语义化发布之后 "),r("a",{attrs:{href:"https://avnpc.com/pages/%5Bhttps://cloud.drone.io/AlloVince/drone-ci-demo/28%5D(https://cloud.drone.io/AlloVince/drone-ci-demo/28)",target:"_blank",rel:"noopener noreferrer"}},[e._v("CI 会将新版本的 Docker 镜像自动发布到 K8s"),r("OutboundLink")],1),e._v("，这里为了演示仅打印了指令并未实际运行。相当于运行了如下的指令:")]),e._v(" "),e._m(54),e._v(" "),r("p",[e._v("由于自动发布的环节势必要接触到生产服务器，需要格外注意安全问题，首推的方式当然是将 CI 和 K8s 集群放于同一内网中，同时可以使用 K8s 的 RBAC 权限控制，为"),r("a",{attrs:{href:"https://avnpc.com/pages/%5Bhttps://github.com/honestbee/drone-kubernetes#rbac%5D(https://github.com/honestbee/drone-kubernetes#rbac)",target:"_blank",rel:"noopener noreferrer"}},[e._v("自动发布单独创建一个用户"),r("OutboundLink")],1),e._v("，并删除不必要的权限。")]),e._v(" "),e._m(55),e._v(" "),r("p",[e._v("总结一下，本文展示了从 "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/tree/hello-world",target:"_blank",rel:"noopener noreferrer"}},[e._v("Hello World"),r("OutboundLink")],1),e._v(" 到 "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/tree/single-person",target:"_blank",rel:"noopener noreferrer"}},[e._v("单人单分支手动发布"),r("OutboundLink")],1),e._v(" 到 "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/tree/gitflow",target:"_blank",rel:"noopener noreferrer"}},[e._v("团队多分支 GitFlow 工作流"),r("OutboundLink")],1),e._v(" 到 "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/tree/semantic-release",target:"_blank",rel:"noopener noreferrer"}},[e._v("团队多分支 semantic-release 语义化发布"),r("OutboundLink")],1),e._v(" 到 "),r("a",{attrs:{href:"https://github.com/AlloVince/drone-ci-demo/tree/k8s-deploy",target:"_blank",rel:"noopener noreferrer"}},[e._v("通知 K8s 全自动发布"),r("OutboundLink")],1),e._v("，如何从零开始一步一步搭建 CI 将团队开发、测试、发布的流程全部自动化的过程，最终能让开发人员只需要认真提交代码就可以完成日常的所有 DevOps 工作。")]),e._v(" "),r("p",[e._v("最终 Step 的完成品可以适配之前的所有 Step，如果不太在意实现细节的话，可以在此基础上稍作修改，直接使用。")]),e._v(" "),r("p",[e._v("然而写好每一个 Commit 这个看似简单的要求，其实对于大多数团队来说并不容易做到，在实施过程中，经常会遇到团队成员不理解为什么要重视 Commit 规范，每个 Commit 都要深思熟虑是否过于吹毛求疵等等疑问。")]),e._v(" "),r("p",[e._v("以 Commit 作为 CI 的核心，个人认为主要会带来以下几方面的影响：")]),e._v(" "),e._m(56),e._v(" "),r("p",[e._v("因此 CI 自动化其实是锦上添花而非雪中送炭，如果团队原本就无视规范，Commit 全是空白或者没有任何意义的单词，分支管理混乱，发布困难，奢望引入一套自动化 CI 来能解决所有这些问题，无疑是不现实的。而只有原本就重视代码质量，有一定规范意识，再通过自动化 CI 来监督约束，团队在 CI 的帮助下代码质量提高，从而有机会进一步改进 CI 的效率，才能形成良性循环。")]),e._v(" "),r("p",[e._v("愿天下不再有难发布的版本。")]),e._v(" "),r("p",[e._v("References:")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/cloud-native/from-kubernetes-to-cloud-native.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("云原生应用之路"),r("OutboundLink")],1)])])])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"docker-容器环境下的持续集成最佳实践："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#docker-容器环境下的持续集成最佳实践：","aria-hidden":"true"}},[this._v("#")]),this._v(" Docker 容器环境下的持续集成最佳实践：")])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("构建基于 Drone + GitFlow + K8s 的云原生语义化 CI 工作流")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("power by https://avnpc.com/pages/drone-gitflow-kubernetes-for-cloud-native-ci")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"主流-ci-cd-应用对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主流-ci-cd-应用对比","aria-hidden":"true"}},[this._v("#")]),this._v(" "),t("a",{attrs:{href:"#%E4%B8%BB%E6%B5%81-cicd-%E5%BA%94%E7%94%A8%E5%AF%B9%E6%AF%94"}},[this._v("#")]),this._v(" 主流 CI/CD 应用对比")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("table",[r("thead",[r("tr",[r("th",[e._v("项目名称")]),e._v(" "),r("th",[e._v("开发语言")]),e._v(" "),r("th",[e._v("配置语言")]),e._v(" "),r("th",[e._v("公有云服务")]),e._v(" "),r("th",[e._v("私有部署")]),e._v(" "),r("th",[e._v("备注")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("Travis CI")]),e._v(" "),r("td",[e._v("Ruby")]),e._v(" "),r("td",[e._v("YAML")]),e._v(" "),r("td",[e._v("有")]),e._v(" "),r("td",[e._v("不支持")]),e._v(" "),r("td",[e._v("公共项目免费,私有项目 $69/单进程, $129/2 进程")])]),e._v(" "),r("tr",[r("td",[e._v("CircleCI")]),e._v(" "),r("td",[e._v("Clojure")]),e._v(" "),r("td",[e._v("YAML")]),e._v(" "),r("td",[e._v("有")]),e._v(" "),r("td",[e._v("不支持")]),e._v(" "),r("td",[e._v("单进程免费，$50/加 1 进程")])]),e._v(" "),r("tr",[r("td",[e._v("Gitlab CI")]),e._v(" "),r("td",[e._v("Ruby")]),e._v(" "),r("td",[e._v("YAML")]),e._v(" "),r("td",[e._v("有")]),e._v(" "),r("td",[e._v("支持")]),e._v(" "),r("td",[e._v("阶梯付费, 免费版功能过少, 绑定 Gitlab")])]),e._v(" "),r("tr",[r("td",[e._v("Jenkins")]),e._v(" "),r("td",[e._v("Java")]),e._v(" "),r("td",[e._v("Groovy")]),e._v(" "),r("td",[e._v("无")]),e._v(" "),r("td",[e._v("支持")]),e._v(" "),r("td")]),e._v(" "),r("tr",[r("td",[e._v("Drone")]),e._v(" "),r("td",[e._v("Go")]),e._v(" "),r("td",[e._v("YAML")]),e._v(" "),r("td",[e._v("有")]),e._v(" "),r("td",[e._v("支持")]),e._v(" "),r("td",[e._v("Cloud 版本不支持私有项目，自建版本无此限制")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"容器环境下一次规范的发布应该包含哪些内容"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容器环境下一次规范的发布应该包含哪些内容","aria-hidden":"true"}},[this._v("#")]),this._v(" "),t("a",{attrs:{href:"#%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%B8%80%E6%AC%A1%E8%A7%84%E8%8C%83%E7%9A%84%E5%8F%91%E5%B8%83%E5%BA%94%E8%AF%A5%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9"}},[this._v("#")]),this._v(" 容器环境下一次规范的发布应该包含哪些内容")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("[ ] 代码的下载构建及编译")]),e._v(" "),r("li",[e._v("[ ] 运行单元测试，生成单元测试报告及覆盖率报告等")]),e._v(" "),r("li",[e._v("[ ] 在测试环境对当前版本进行测试")]),e._v(" "),r("li",[e._v("[ ] 为待发布的代码打上版本号")]),e._v(" "),r("li",[e._v("[ ] 编写 ChangeLog 说明当前版本所涉及的修改")]),e._v(" "),r("li",[e._v("[ ] 构建 Docker 镜像")]),e._v(" "),r("li",[e._v("[ ] 将 Docker 镜像推送到镜像仓库")]),e._v(" "),r("li",[e._v("[ ] 在预发布环境测试当前版本")]),e._v(" "),r("li",[e._v("[ ] 正式发布到生产环境")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"ci-流程演示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ci-流程演示","aria-hidden":"true"}},[this._v("#")]),this._v(" "),t("a",{attrs:{href:"#ci-%E6%B5%81%E7%A8%8B%E6%BC%94%E7%A4%BA"}},[this._v("#")]),this._v(" CI 流程演示")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"单人开发模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单人开发模式","aria-hidden":"true"}},[this._v("#")]),this._v(" "),t("a",{attrs:{href:"#%E5%8D%95%E4%BA%BA%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"}},[this._v("#")]),this._v(" 单人开发模式")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ol",[r("li",[e._v("Clone 项目到本地， 修改项目代码， 如将 "),r("code",[e._v("Hello World")]),e._v(" 改为 "),r("code",[e._v("Hello World V2")]),e._v("。")]),e._v(" "),r("li",[r("code",[e._v("git add .")]),e._v("，然后书写符合约定的 Commit 并提交代码， "),r("code",[e._v('git commit -m "feature: hello world v2”')])]),e._v(" "),r("li",[e._v("推送代码到代码库"),r("code",[e._v("git push")]),e._v("，等待数分钟后，开发人员会看到单元测试结果，Github 仓库会产生一次新版本的 release，release 内容为当前版本的 ChangeLog， 同时线上已经完成了新功能的发布。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"多人开发模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多人开发模式","aria-hidden":"true"}},[this._v("#")]),this._v(" "),t("a",{attrs:{href:"#%E5%A4%9A%E4%BA%BA%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"}},[this._v("#")]),this._v(" 多人开发模式")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ol",[r("li",[e._v("Clone 项目到本地，创建一个分支来完成新功能的开发, "),r("code",[e._v("git checkout -b feature/hello-world-v3")]),e._v("。在这个分支修改一些代码，比如将"),r("code",[e._v("Hello World V2")]),e._v("修改为"),r("code",[e._v("Hello World V3")])]),e._v(" "),r("li",[r("code",[e._v("git add .")]),e._v("，书写符合规范的 Commit 并提交代码， "),r("code",[e._v('git commit -m "feature: hello world v3”')])]),e._v(" "),r("li",[e._v("将代码推送到代码库的对应分支， "),r("code",[e._v("git push origin feature/hello-world")])]),e._v(" "),r("li",[e._v("如果功能已经开发完毕，可以向 Master 分支发起一个 Pull Request，并让项目的负责人 Code Review")]),e._v(" "),r("li",[e._v("Review 通过后，项目负责人将分支合并入主干，Github 仓库会产生一次新版本的 release，同时线上已经完成了新功能的发布。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"gitflow-开发模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gitflow-开发模式","aria-hidden":"true"}},[this._v("#")]),this._v(" "),t("a",{attrs:{href:"#gitflow-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"}},[this._v("#")]),this._v(" GitFlow 开发模式")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("以 dev 为主开发分支，master 为发布分支")]),e._v(" "),r("li",[e._v("开发人员始终从 dev 创建自己的分支，如 feature-a")]),e._v(" "),r("li",[e._v("feature-a 开发完毕后创建 PR 到 dev 分支，并进行 code review")]),e._v(" "),r("li",[e._v("review 后 feature-a 的新功能被合并入 dev，如有多个并行功能亦然")]),e._v(" "),r("li",[e._v("待当前开发周期内所有功能都合并入 dev 后，从 dev 创建 PR 到 master")]),e._v(" "),r("li",[e._v("dev 合并入 master，并创建一个新的 release")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ol",[r("li",[e._v("Clone 项目到本地，"),r("code",[e._v("git checkout dev")]),e._v("。从 dev 创建一个分支来完成新功能的开发, "),r("code",[e._v("git checkout -b feature/feature-a")]),e._v("。在这个分支修改一些代码，比如将"),r("code",[e._v("Hello World V3")]),e._v("修改为"),r("code",[e._v("Hello World Feature A")])]),e._v(" "),r("li",[r("code",[e._v("git add .")]),e._v("，书写符合规范的 Commit 并提交代码， "),r("code",[e._v('git commit -m "feature: hello world feature A"')])]),e._v(" "),r("li",[e._v("将代码推送到代码库的对应分支， "),r("code",[e._v("git push origin feature/feature-a:feature/feature-a")])]),e._v(" "),r("li",[e._v("由于分支是以"),r("code",[e._v("feature/")]),e._v("命名的，因此 CI 会运行单元测试，并自动构建一个当前分支的镜像，发布到测试环境，并自动配置一个当前分支的域名如 "),r("code",[e._v("test-featue-a.avnpc.com")])]),e._v(" "),r("li",[e._v("联系产品及测试同学在测试环境验证并完善新功能")]),e._v(" "),r("li",[e._v("功能通过验收后发起 PR 到 dev 分支，由 Leader 进行 code review")]),e._v(" "),r("li",[e._v("Code Review 通过后，Leader 合并当前 PR，此时 CI 会运行单元测试，构建镜像，并发布到测试环境")]),e._v(" "),r("li",[e._v("此时 dev 分支有可能已经积累了若干个功能，可以访问测试环境对应 dev 分支的域名，如 "),r("code",[e._v("test.avnpc.com")]),e._v("，进行集成测试。")]),e._v(" "),r("li",[e._v("集成测试完成后，由运维同学从 Dev 发起一个 PR 到 Master 分支，此时会 CI 会运行单元测试，构建镜像，并发布到预发布环境")]),e._v(" "),r("li",[e._v("测试人员在预发布环境下再次验证功能，团队做上线前的其他准备工作")]),e._v(" "),r("li",[e._v("运维同学合并 PR，CI 将为本次发布的代码及镜像自动打上版本号并书写 ChangeLog，同时发布到生产环境。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"step-by-step-构建-ci-工作流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#step-by-step-构建-ci-工作流","aria-hidden":"true"}},[this._v("#")]),this._v(" "),t("a",{attrs:{href:"#step-by-step-%E6%9E%84%E5%BB%BA-ci-%E5%B7%A5%E4%BD%9C%E6%B5%81"}},[this._v("#")]),this._v(" Step by Step 构建 CI 工作流")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"step-0-基于-k8s-部署-drone-v1-0-0"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#step-0-基于-k8s-部署-drone-v1-0-0","aria-hidden":"true"}},[this._v("#")]),this._v(" "),t("a",{attrs:{href:"#step0-%E5%9F%BA%E4%BA%8E-k8s-%E9%83%A8%E7%BD%B2-drone-v100"}},[this._v("#")]),this._v(" Step.0: 基于 K8s 部署 Drone v1.0.0")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("kubectl apply -f drone-pvc.yaml\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[t("code",[this._v("drone/kubernetes-secrets")]),this._v(" 加密数据服务，用于读取 K8s 的 secrets")]),this._v(" "),t("li",[t("code",[this._v("drone/drone:1.0.0-rc.6")]),this._v(" 就是 Drone 的 server 端，由于在 K8s 下 Drone 利用了 Job 机制，因此不需要部署 agent。")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[r("code",[e._v("drone/kubernetes-secrets")]),e._v(" 镜像中\n"),r("ul",[r("li",[r("code",[e._v("SECRET_KEY")]),e._v(": 数据加密传输所用的 key，可以使用 "),r("code",[e._v("openssl rand -hex 16")]),e._v(" 生成一个")])])]),e._v(" "),r("li",[r("code",[e._v("drone/drone")]),e._v("镜像中\n"),r("ul",[r("li",[r("code",[e._v("DRONE_KUBERNETES_ENABLED")]),e._v(": 开启 K8s 模式")]),e._v(" "),r("li",[r("code",[e._v("DRONE_KUBERNETES_NAMESPACE")]),e._v(": Drone 所使用的 Namespace， 这里使用 "),r("code",[e._v("default")])]),e._v(" "),r("li",[r("code",[e._v("DRONE_GITHUB_SERVER")]),e._v(": Github 服务器地址，一般为 "),r("code",[e._v("https://github.com")])]),e._v(" "),r("li",[r("code",[e._v("DRONE_GITHUB_CLIENT_ID")]),e._v(": 上文创建 Github Auth App 得到的 "),r("code",[e._v("Client ID")])]),e._v(" "),r("li",[r("code",[e._v("DRONE_GITHUB_CLIENT_SECRET")]),e._v(": 上文创建 Github Auth App 得到的 "),r("code",[e._v("Client Secret")])]),e._v(" "),r("li",[r("code",[e._v("DRONE_SERVER_HOST")]),e._v(": Drone 服务所使用的域名")]),e._v(" "),r("li",[r("code",[e._v("DRONE_SERVER_PROTO")]),e._v(": http 或 https")]),e._v(" "),r("li",[r("code",[e._v("DRONE_DATABASE_DRIVER")]),e._v(": Drone 使用的数据库类型，这里为 "),r("code",[e._v("sqlite3")])]),e._v(" "),r("li",[r("code",[e._v("DRONE_DATABASE_DATASOURCE")]),e._v(": 这里为 SQLite 数据库的存放路径")]),e._v(" "),r("li",[r("code",[e._v("DRONE_SECRET_SECRET")]),e._v(": 对应上文的 "),r("code",[e._v("SECRET_KEY")])]),e._v(" "),r("li",[r("code",[e._v("DRONE_SECRET_ENDPOINT")]),e._v(": 加密数据服务的地址，这里通过 k8s service 暴露，无需修改")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("kubectl apply -f drone.yaml\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("部署后首次登录 Drone 就会跳转到 Github Auth App 进行授权，授权完毕后可以看到所有能读写的 Repo，选择需要开启 CI 的 Repo，点击 "),t("code",[this._v("ACTIVATE")]),this._v(" 即可。 如果开启成功，在 Github Repo 的 Settings > Webhooks 下可以看到 Drone 的回调地址。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"step-1-hello-world-for-drone"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#step-1-hello-world-for-drone","aria-hidden":"true"}},[this._v("#")]),this._v(" "),t("a",{attrs:{href:"#step1-hello-world-for-drone"}},[this._v("#")]),this._v(" Step.1: Hello World for Drone")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("在正式开始搭建工作流之前，首先可以测试一下 Drone 是否可用。Drone 默认的配置文件是 "),t("code",[this._v(".drone.yml")]),this._v("， 在需要 CI 的 repo 根目录下创建"),t("code",[this._v(".drone.yml")]),this._v("， 内容如下，提交并"),t("code",[this._v("git push")]),this._v("到代码仓库即可触发 Drone 执行 CI。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v('kind: pipeline  \nname: deploy  \n  \nsteps:  \n- name: hello-world\n  image: docker  \n  commands:  \n    - echo "hello world"\n')])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Drone v1 的语法主要参考的 K8s 的语法，非常直观，无需阅读文档也可以知道，我们首先定义了一个管道 (pipeline)，管道由若干步骤 (step) 组成，Drone 的每个步骤是都基于容器实现的，因此 Step 的语法就回到了我们熟悉的 Docker，一个 Step 会拉取 "),t("code",[this._v("image")]),this._v(" 定义的镜像，然后运行该镜像，并顺序执行 "),t("code",[this._v("commands")]),this._v(" 定义的指令。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:"https://static.avnpc.com/blog/2019/drone_hello_world.png",alt:""}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"step-2-单人工作流，自动化单元测试与-docker-镜像构建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#step-2-单人工作流，自动化单元测试与-docker-镜像构建","aria-hidden":"true"}},[this._v("#")]),this._v(" "),t("a",{attrs:{href:"#step2-%E5%8D%95%E4%BA%BA%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E-docker-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA"}},[this._v("#")]),this._v(" Step.2: 单人工作流，自动化单元测试与 Docker 镜像构建")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("为了方便说明，这里假设项目语言为 js，项目内新增了"),t("code",[this._v("test/index.js")]),this._v("文件用于模拟单元测试，一般在 CI 中，只要程序的返回值为 0，即代表运行成功。这个文件中我们仅仅输出一行 Log "),t("code",[this._v("Unit test passed")]),this._v("用于模拟单元测试通过。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("我们希望将代码打包成 Docker 镜像，根目录下增加了 "),t("code",[this._v("Dockerfile")]),this._v(" 文件，这里直接使用 Nginx 的官方镜像，构建过程只有 1 行"),t("code",[this._v("COPY index.html /usr/share/nginx/html/")]),this._v("， 这样镜像运行后可以通过 http 请求看到"),t("code",[this._v("index.html")]),this._v("的内容。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("当 master 分支接收到 push 后，运行单元测试")]),this._v(" "),t("li",[this._v("当 github 发布一次 release， 构建 Docker 镜像，并推送到镜像仓库")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("kind: pipeline  \nname: deploy  \n  \nsteps:  \n  - name: unit-test  \n    image: node:10  \n    commands:  \n      - node test/index.js  \n    when:  \n      branch: master  \n      event: push  \n\n  - name: build-image  \n    image: plugins/docker  \n    settings:  \n      repo: allovince/drone-ci-demo  \n      username: allovince  \n      password:  \n        from_secret: DOCKER_PASSWORD  \n      auto_tag: true  \n    when:  \n      event: tag\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("Plugin 插件")]),this._v("，上例中用于构建和推送镜像的是 "),t("code",[this._v("plugins/docker")]),this._v(" 这个 Plugin， 一个 Plugin 本质上仍然是一个 Docker 镜像，只是按照 Drone 的规范接受特定的输入，并完成特定的操作。所以完全可以将 Plugin 看做一个无法更改 command 的 Docker 镜像。")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("p",[e._v("此外 Docker 插件还有一个很方便的功能，如果设置 "),r("code",[e._v("auto_tag: true")]),e._v("，将根据代码的版本号自动规划 Docker 镜像的标签，如代码版本为"),r("code",[e._v("1.0.0")]),e._v("，将为 Docker 镜像打三个标签 "),r("code",[e._v("1")]),e._v(", "),r("code",[e._v("1.0")]),e._v(", "),r("code",[e._v("1.0.0")]),e._v("。如果代码版本号不能被解析，则镜像标签为 "),r("code",[e._v("latest")]),e._v("。")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("p",[r("strong",[e._v("Secret 加密数据")]),e._v("，镜像仓库的用户名和密码都属于敏感信息，因此可以使用 "),r("code",[e._v("from_secret")]),e._v(" 获取加密数据。一条加密数据就是一个 key / value 对，如上例中的 "),r("code",[e._v("DOCKER_PASSWORD")]),e._v(" 就是我们自己定义的加密数据 key。即便加密数据在 log 中被打印，UI 也只能看到 "),r("code",[e._v("***")]),e._v("。加密数据的 value 需要提前保存好，保存的方式有 3 种：")])},function(){var e=this.$createElement,t=this._self._c||e;return t("li",[this._v("release 后 CI 构建的 Docker 镜像: "),t("code",[this._v("allovince/drone-ci-demo:latest")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"step-3-gitflow-多分支团队工作流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#step-3-gitflow-多分支团队工作流","aria-hidden":"true"}},[this._v("#")]),this._v(" "),t("a",{attrs:{href:"#step3-gitflow-%E5%A4%9A%E5%88%86%E6%94%AF%E5%9B%A2%E9%98%9F%E5%B7%A5%E4%BD%9C%E6%B5%81"}},[this._v("#")]),this._v(" Step.3: GitFlow 多分支团队工作流")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("- name: unit-test  \n  image: node:10  \n  commands:  \n    - node test/index.js  \n  when:  \n    branch:  \n      include:  \n        - feature/*  \n        - master  \n        - dev  \n    event:  \n      include:  \n        - push  \n        - pull_request\n")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("p",[e._v("然后根据 Gitflow 的流程对于不同的分支构建 Docker 镜像并打上特定标签，以 feature 分支为例，下面的配置约定了当分支名满足 "),r("code",[e._v("feature/*")]),e._v("，并收到 push 时，会构建 Docker 镜像并打标签，标签名称为当前分支名去掉 "),r("code",[e._v("feature/")]),e._v("。如分支 "),r("code",[e._v("feature/readme")]),e._v("， 对应 docker 镜像为 "),r("code",[e._v("allovince/drone-ci-demo:readme")]),e._v("，考虑到 feature 分支一般都出于开发阶段，因此新的镜像会覆盖旧的。配置如下")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("- name: build-branch-image  \n  image: plugins/docker  \n  settings:  \n    repo: allovince/drone-ci-demo  \n    username: allovince  \n    password:  \n      from_secret: DOCKER_PASSWORD  \n    tag:  \n      - ${DRONE_BRANCH##feature/}  \n  when:  \n    branch: feature/*  \n    event: push\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("可能细心的同学会发现 dev -> master 的 pull request 时，构建镜像失败了，这是由于 Drone 出于安全考虑限制了在 pull request 时默认无法读取加密数据，因此无法得到 Docker Registry 密码。如果是私有部署的话，可以在 Repo Settings 中勾选"),t("code",[this._v("Allow Pull Requests")]),this._v("，此处就可以构建成功。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"step-4-语义化发布"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#step-4-语义化发布","aria-hidden":"true"}},[this._v("#")]),this._v(" "),t("a",{attrs:{href:"#step4-%E8%AF%AD%E4%B9%89%E5%8C%96%E5%8F%91%E5%B8%83"}},[this._v("#")]),this._v(" Step.4: 语义化发布")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ol",[t("li",[this._v("主版本号：当你做了不兼容的 API 修改，")]),this._v(" "),t("li",[this._v("次版本号：当你做了向下兼容的功能性新增，")]),this._v(" "),t("li",[this._v("修订号：当你做了向下兼容的问题修正。")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[r("strong",[e._v("feat")]),e._v(": 新功能")]),e._v(" "),r("li",[r("strong",[e._v("fix")]),e._v(": BUG 修复")]),e._v(" "),r("li",[r("strong",[e._v("docs")]),e._v(": 文档变更")]),e._v(" "),r("li",[r("strong",[e._v("style")]),e._v(": 文字格式修改")]),e._v(" "),r("li",[r("strong",[e._v("refactor")]),e._v(": 代码重构")]),e._v(" "),r("li",[r("strong",[e._v("perf")]),e._v(": 性能改进")]),e._v(" "),r("li",[r("strong",[e._v("test")]),e._v(": 测试代码")]),e._v(" "),r("li",[r("strong",[e._v("chore")]),e._v(": 工具自动生成")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("当 Commit 内容较多时，可以追加正文和脚注，如果正文起始为"),t("code",[this._v("BREAKING CHANGE")]),this._v("，代表这是一个破坏性变更。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("feat: 增加重置密码功能\n\n\nfix(邮件模块): 修复邮件发送延迟BUG\n\n\nfeat(API): API重构\n\nBREAKING CHANGE: API v3上线，API v1停止支持\n")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("table",[r("thead",[r("tr",[r("th",[e._v("Commit")]),e._v(" "),r("th",[e._v("版本号变更")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[r("code",[e._v("BREAKING CHANGE")])]),e._v(" "),r("td",[e._v("主版本号")])]),e._v(" "),r("tr",[r("td",[r("code",[e._v("feat")])]),e._v(" "),r("td",[e._v("次版本号")])]),e._v(" "),r("tr",[r("td",[r("code",[e._v("fix")]),e._v(" / "),r("code",[e._v("perf")])]),e._v(" "),r("td",[e._v("修订号")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("最后在 "),t("code",[this._v(".drone.yml")]),this._v(" 中增加这样一段就可以了。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("- name: semantic-release  \n  image: gtramontina/semantic-release:15.13.3  \n  environment:  \n    GITHUB_TOKEN:  \n      from_secret: GITHUB_TOKEN  \n  entrypoint:  \n    - semantic-release  \n  when:  \n    branch: master  \n    event: push\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:"https://static.avnpc.com/blog/2019/semantic_release_at_github.png",alt:""}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"step-5-kubernetes-自动发布"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#step-5-kubernetes-自动发布","aria-hidden":"true"}},[this._v("#")]),this._v(" "),t("a",{attrs:{href:"#step5-kubernetes-%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83"}},[this._v("#")]),this._v(" Step.5: Kubernetes 自动发布")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Docker 镜像推送到仓库后，我们还剩最后一步就可以完成全自动发布的闭环，即通知 Kubernetes 将镜像发布到生产环境。这一步实现比较灵活，因为很多云服务商在容器服务都会提供 Trigger 机制，一般是提供一个 URL，只要请求这个 URL 就可以触发容器服务的发布。Demo 中我们使用更为通用的方法，就是将 "),t("code",[this._v("kubectl")]),this._v(" 打包为容器，以客户端调用 K8s 集群 Master 节点 API ( "),t("code",[this._v("kube-apiserver")]),this._v(" ) 的形式完成发布。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("---  \napiVersion: extensions/v1beta1  \nkind: Deployment  \nmetadata:  \n  name: ci-demo-deployment  \n  namespace: default  \nspec:  \n  replicas: 1  \n  template:  \n    spec:  \n      containers:  \n        - image: allovince/drone-ci-demo  \n          name: ci-demo  \n      restartPolicy: Always\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("- name: k8s-deploy  \n  image: quay.io/honestbee/drone-kubernetes  \n  settings:  \n    kubernetes_server:  \n      from_secret: KUBERNETES_SERVER  \n    kubernetes_cert:  \n      from_secret: KUBERNETES_CERT  \n    kubernetes_token:  \n      from_secret: KUBERNETES_TOKEN  \n    namespace: default  \n    deployment: ci-demo-deployment  \n    repo: allovince/drone-ci-demo  \n    container: ci-demo  \n    tag:  \n      - ${DRONE_TAG}  \n  when:  \n    event: tag\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("kubectl -n default set image deployment/ci-demo-deployment ci-demo=allovince/drone-ci-demo:v1.0.2\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"后话"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后话","aria-hidden":"true"}},[this._v("#")]),this._v(" "),t("a",{attrs:{href:"#%E5%90%8E%E8%AF%9D"}},[this._v("#")]),this._v(" 后话")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ol",[r("li",[e._v("一个好的 Commit，代表着开发人员对当前改动之于整个系统的影响，有非常清楚的认识，代码的修改到底算 "),r("code",[e._v("feat")]),e._v(" 还是 "),r("code",[e._v("fix")]),e._v(" ，什么时候用 "),r("code",[e._v("BREAKING CHANGE")]),e._v(" 等都是要仔细斟酌的，每个 Commit 都会在 ChangeLog 里“留底”，从而约束团队不随意提交未经思考的代码，提高代码质量")]),e._v(" "),r("li",[e._v("一个好的 Commit 也代表开发人员有能力对所实现功能进行精细的划分，一个分支做的事情不宜过多，一个提交也应该专注于只解决一个问题，每次提交(至少是每次 push )都应该保持系统可构建、可运行、可测试，如果能坚持做到这些，对于合并代码时的冲突解决，以及集成测试都有很大帮助。")]),e._v(" "),r("li",[e._v("由于每次发布能清楚的看到所有关联的 Commit 以及 Commit 的重要程度，那么线上事故的回滚也会非常轻松，回滚到哪个版本，回滚后哪些功能会受到影响，只要看 CI 自动生成的 Release 记录就一目了然。如果没有这些，回滚误伤到预期外的功能从而引发连锁反应的惨痛教训，可能很多运维都有过类似经历吧。")])])}],!1,null,null,null);t.default=o.exports}}]);