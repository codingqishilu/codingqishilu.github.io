# server跟client

## 1、Swoole-server介绍

server，顾名思义，就是服务端。我们平时接触比较多的无非就是nginx和apache。作为webServer，二者都是通过监听某端口对外提供服务,swoole的server也不例外同样需要绑定端口,同时能够提供给客户端相关的服务。

## 2、创建一个Tcp server

创建server的步骤:

   - 1、实例化Server对象
   - 2、设置运行时参数
   - 3、注册事件回调函数
   - 4、启动服务器
   
```php

<?php
/**
 * Created by PhpStorm.
 * User: shisiying
 * Date: 2019-04-06
 * Time: 17:29
 */


//创建server对象，监听9051端口
$serv = new swoole_server('0.0.0.0',9051);

$serv->on('connect',function ($serv,$fd){
    echo "有新的客户端连接,连接标示为$fd".PHP_EOL;
});

$serv->on('receive',function ($serv,$fd,$from_id,$data){
   $serv->send($fd,"服务器给你发送消息了：".$data);
});

$serv->on("close",function ($serv,$fd){
    echo "编号为{$fd}的客户端已经关闭".PHP_EOL;
});

//启动服务器
$serv->start();



```

由于swoole_server只能运行在CLI模式下，所以不要试图通过浏览器进行访问，有听说过apache是基于nginx运行的吗，大家地位相同，只能配合，没有上下关系
我们平时执行完一个指令，执行完就结束了，但是现在的情况正好相反，当前程序一直处于执行中的状态，并没有退出终端。同时因为swoole的server是常驻内存运行的，所以如果
修改了代码，需要ctrl+c中断，重新运行才行。

在我们第一步初始化server所填写的ip和端口吗，也就是说server现在正在监听9501端口提供服务。
## 3、创建一个Client

swoole_client的构造函数如下所示：

```php
swoole_client->__construct($sock_type,SWOOLE_SOCK_SYNC, $key);

```

>第一个参数：
 SWOOLE_SOCK_TCP 创建tcp socket
 SWOOLE_SOCK_TCP6 创建tcp ipv6 socket
 SWOOLE_SOCK_UDP 创建udp socket
 SWOOLE_SOCK_UDP6 创建udp ipv6 socket
 第二个参数表示是同步还是异步
 SWOOLE_SOCK_SYNC 同步客户端
 SWOOLE_SOCK_ASYNC 异步客户端
 第三个参数(暂不了解)
 用于长连接的Key，默认使用IP:PORT作为key。相同key的连接会被复用


Client分为同步Client跟异步Client

同步client是同步阻塞的。一整套connect->send()->rev()->close()是同步进行的。如果需要大量的数据处理，后台不能在规定的时间内返回数据会导致接收超时，并且因为是同步执行所以需要等待后台数据的返回。

当设定swoole_client为异步模式后，swoole_client就不能使用recv方法了，而需要通过on方法提供指定的回调函数，然后在回调函数当中处理

- 同步跟异步概念

同步: 当一个同步调用发出去后，调用者要一直等待调用结果的通知后，才能进行后续的执行。 

异步：当一个异步调用发出去后，调用者不能立即得到调用结果的返回。 


生活中的例子：

同步买奶茶：小明点单交钱，然后等着拿奶茶；

异步买奶茶：小明点单交钱，店员给小明一个小票，等小明奶茶做好了，再来取

同步客户端代码

```php
<?php
/**
 * Created by PhpStorm.
 * User: shisiying
 * Date: 2019-04-20
 * Time: 16:47
 */
$client = new swoole_client(SWOOLE_SOCK_TCP);
if (!$client->connect('0.0.0.0', 9051, -1))
{
    exit("connect failed. Error: {$client->errCode}\n");
}
$client->send("hello world\n");
echo $client->recv();
$client->close();
```
## 4、swoole驱动模式及相应事件

swoole另外一个比较吸引人的地方，就是swoole_server是事件驱动的。我们在使用的过程中不需要关注底层是怎么实现的，底层是C写的php只是做了个传递的作用，所以只需要对底层相应的动作注册相应的回调，在回调函数中处理业务逻辑即可。
什么意思呢？我举个例子：
你启动了一个server，当客户端连接的时候（触发事件），你不需要关心它是怎么连接的，你就单纯的注册一个connect函数，做一些连接后的业务处理即可(执行业务)。类似于js的事件监听，比如触发了click事件，就会执行相应的闭包。
Swoole监听的事件：

![](http://ww1.sinaimg.cn/large/0061MNOzgy1g2abihwkt3j308109tjrb.jpg)

## 5、tcp/ip协议分层

- 什么是网络协议?

网络协议为计算机网络中进行数据交换而建立的规则、标准或约定的集合

- 协议分层

TCP/IP协议族是一个四层协议系统，自底而上分別是数据链路层、网络层、传输层和应用层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务

![](http://ww1.sinaimg.cn/large/0061MNOzgy1g2abihy96pj30hz08b0vi.jpg)
- 数据链路层
  
  数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理媒介上的传输。
数据链路展两个常用的协议是ARP协议（Address Resolve Protocol,地址解析协议）和RARP协议（Reverse Address Resolve Protocol,逆地址解析协议）.它们实现了 IP地址和机器物理地址（MAC地址）之间的相互转换，那处理的流程是怎么样的呢？

当数据交换时上层网络层使用IP地址寻找一台机器，而数据链路层使用物理地址寻找一台机器，因此网络层必须先将目标标机器的IP地址转化成其物理地址,才能使用数据链路提供的服务，这就 ARP协议的用途 

- 网络层

网络层实现数据包的选路和转发，网络层最核心的协议是IP协议（Internet Protocol,因特网协议）。IP协议根据数据包的目的IP地址来决定如何投递它。

网络层另外一个重要的协议足ICMP协议（Internet Control Message Protocol»因特网控制报文协议）。它是IP协议的重要要补充，主要用于检测网络连接，比如可以通过发送报文来检测目标是否可达

- 传输层

网络层当中的IP协议为了解决传输当中的路径选择的问题，只需要按照此路径传输数据即可，传输层利用udp或者tcp协议以及网络层提供的路径信息为基础完成实际的数据传输，所以称为传输层

TCP和UDP对比介绍

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3、tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。

3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。

4、TCP对系统资源要求较多，UDP对系统资源要求较少。

- 应用层
  
应用层负责处理应用程序的逻辑。数据链路层、网络层和传输层负责处理网络通讯细节，这部分必须既稳定又高效,因此它们都在内核空间中实现，应用层则负责在用户户空间实现，因为为它负责处理众多逻辑。
应用层协议举例：
  
FTP文件传输协议是TCP/IP网络上两台计算机传送文件的协议
  
SMTP（SimpleMailTransferProtocol）即简单邮件传输协议

## 6、长连接心跳问题解析

- 心跳是啥？

顾名思义，心跳是判断一个事物生还是死的一个标准，在swoole里，心跳是指用来判断一个连接是正常还是断开的

- 为什么要心跳？

心跳的目的其实是通过判断客户端是否存活，从而回收fd,系统为什么要回收fd，因为fd资源是有限的，所以必需重复利用 

心跳作用主要有两个： 

   1、客户端定时给服务端发送点数据，防止连接由于长时间没有通讯而被某些节点的防火墙关闭导致连接断开的情况。
    
   2、服务端可以通过心跳来判断客户端是否在线，如果客户端在规定时间内没有发来任何数据，就认为客户端下线。这样可以检测到客户端由于极端情况(断电、断网等)下线的事件。

- 心跳在swoole里的实现?

    swoole会在主进程独立起一个心跳线程，通过定时轮询所有的连接，来判断连接的生死，所以swoole的心跳不会堵塞任何业务逻辑。

具体代码设置

```php
$serv->set([
    'worker_num'=>1,//设置进程
    'heartbeat_idle_time'=>10,//连接最大的空闲时间
    'heartbeat_check_interval'=>3//服务器定时检测在线列表的时间
]);
```

- 为什么需要心跳包？客户端如何维持心跳？

    在从客户端到服务器的一条巨大的链路中会经过无数的路由器，其中每一个路由器都有可能会有检测到多少秒时间内无数据包则自动关闭连接的这种节能机制，为了让这个可能会出现的节能机制失效，客户端可以设置一个定时器，每隔固定的时间都发一个随机字符的一字节的数据包，通常我们把这种数据包就叫做心跳包。





## 7、tcp的特点及粘包处理

- TCP通信特点

    1.TCP 是流式协议没有消息边界，客户端向服务器端发送一次数据，可能会被服务器端分成多次收到。客户端向服务器端发送多条数据。服务器端可能一次全部收到。
    
    2.保证传输的可靠性，顺序。
    
    3.TCP拥有拥塞控制，所以数据包可能会延后发送。

- 没有消息边界:

    可以理解为水在一个水管里的流动，我们不知道哪段数据是一个我们需要的完整数据

- 收发有缓冲区:

    比如：当水从一端流到了另一端，我们在收数据的时候，不可能每来一滴水就处理一次，这个缓冲区就相当于有了一个水桶，再接了一定的水之后内核再给数据交到用户空间，这样可以大大提升性能。

- 什么是 TCP 粘包？

    TCP 粘包是指发送方发送的若干包数据 到 接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。
    
- TCP 出现粘包的原因？

    发送方：发送方需要等缓冲区满才发送出去，造成粘包
    
    接收方：接收方不及时接收缓冲区的包，造成多个包接收

    tcp协议传输数据的过程

    ![](http://ww1.sinaimg.cn/large/0061MNOzgy1g2abihydicj30q307ltaf.jpg)

- Swoole怎么处理粘包


1）通过约定结束符，来确定包数据是否发送完毕

开启open_eof_check=true,并用package_eof来设置一个完整数据结尾字符，同时设置自动拆分open_eof_split

例如：

```php
$serv->set([
    'worker_num'=>1,//设置进程
    'open_eof_check'=true,//打开EOF检测
    'package_eof'=>"\r\n",//设置EOF
    'open_eof_split'=>true//开启自动拆分
]);
```

值得注意的是：

1、要保证业务数据里不能出现package_eof设置的字符,否则将导致数据错误了。

2、可以手动拆包，去掉open_eof_split,自行 explode("\r\n", $data),然后循环发送

2）固定包头+包体协议

这种方式也非常常见，原理是通过约定数据流的前几个字节来表示一个完整的数据有多长，从第一个数据到达之后，先通过读取固定的几个字节，解出数据包的长度，然后按这个长度继续取出后面的数据，依次循环。

如下所示：

```php
$serv->set([
    'open_length_check'=>1,
    'package_length_type'=>'N',//设置包头的长度
    'package_length_offset'=>0, //包长度从哪里开始计算
    'package_body_offset'=>4,  //包体从第几个字节开始计算
    'package_max_length'=>1024 * 1024 * 2,
]);
```

相关配置：

open_length_check：打开包长检测特性

package_length_type：长度字段的类型，固定包头中用一个4字节或2字节表示包体长度。

package_length_offset：从第几个字节开始是长度，比如包头长度为120字节，第10个字节为长度值，这里填入9（从0开始计数）

package_body_offset：从第几个字节开始计算长度，比如包头为长度为120字节，第10个字节为长度值，包体长度为1000。如果长度包含包头，这里填入0，如果不包含包头，这里填入120

package_max_length：最大允许的包长度。因为在一个请求包完整接收前，需要将所有数据保存在内存中，所以需要做保护。避免内存占用过大。

package_length_type 长度值的类型

长度值的类型，接受一个字符参数，与php的pack函数一致。目前swoole支持10种类型：

c：有符号、1字节

C：无符号、1字节

s：有符号、主机字节序、2字节

S：无符号、主机字节序、2字节

n：无符号、网络字节序、2字节 (常用)

N：无符号、网络字节序、4字节 (常用)

l：有符号、主机字节序、4字节（小写L）

L：无符号、主机字节序、4字节（大写L）

v：无符号、小端字节序、2字节

V：无符号、小端字节序、4字节

## 字节序的理解

计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）。

大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。

小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。

- 为什么要有字节序呢？

计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。

不过，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。

所以我们要确定通信双方交流的信息单元应该以什么样的顺序进行传送。如果达不成一致的规则，计算机的通信与存储将会无法进行
